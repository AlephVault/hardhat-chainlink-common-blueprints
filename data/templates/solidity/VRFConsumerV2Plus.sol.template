// SPDX-License-Identifier: MIT
pragma solidity #SOLIDITY_VERSION#;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

/**
 * This contract is a VRF consumer. This is a default implementation that
 * can be changed later at user's please (as long as the call to
 * `requestRandomWords` is done, it will work and the user can tune it
 * to have many call implementations).
 */
contract #SCRIPT_NAME# is VRFConsumerBaseV2Plus {
    uint256 constant subscriptionId = #SUBSCRIPTION_ID#;
    address constant vrfCoordinator = #VRF_COORDINATOR#;
    bytes32 constant keyHash = #KEY_HASH#;
    uint32 constant callbackGasLimit = #CALLBACK_GAS_LIMIT#; // Default: 4000
    uint16 constant requestConfirmations = #REQUEST_CONFIRMATIONS#; // Default: 3
    uint32 constant numWords = #NUM_WORDS#; // Default: 1
    bool constant nativePayments = #USE_NATIVE_PAYMENTS#; // Defailt: false

    /**
     * The status of the request.
     */
    enum RequestStatus { Invalid, Pending, Completed }

    /**
     * This event is dapp-specific to tell that the request has
     * started. Users should listen for this event and do any
     * processing, typically understanding that the dapp will
     * be properly updated.
     */
    // Modify this event as much as you want, but always keeping
    // in mind that you can have up to 3 indexed arguments and
    // typically you might like requestId to be one of them.
    event RequestStarted(uint256 indexed requestId);

    /**
     * This event is dapp-specific to tell that the request has
     * completed. Users should listen for this event and do any
     * processing, typically understanding that the dapp will
     * be properly updated.
     */
    // Modify this event as much as you want, but always keeping
    // in mind that you can have up to 3 indexed arguments and
    // typically you might like requestId to be one of them.
    event RequestCompleted(uint256 indexed requestId);

    /**
     * The request, being tracked for completion. This request
     * will hold dapp-logic related to the launched request (an
     * example: who launched the request and some extra context
     * to be used in the words-fulfillment handling).
     */
    struct Request {
        /**
         * The status of the request. Check against Invalid to detect whether
         * a given request ID was never issued.
         */
        RequestStatus status;
        // Add more variables you deem useful here.
    }

    /**
     * The in-progress and fulfilled requests.
     */
    mapping(uint256 => Request) private requests;

    // Add more parameters to this constructor when needed.
    constructor() VRFConsumerBaseV2Plus(vrfCoordinator) {}

    /**
     * This internal function is the responsible of requiring
     * the random numbers to the VRF service.
     */
    // It's name can be changed, and also the required arguments
    // or even the output arguments (return values), visibility
    // and modifiers. The important part is that this function
    // is the entry point to request random numbers and that it
    // must be modified enough so it is not freely invokable by
    // external users or contracts, but by certain rules instead
    // (e.g. as part of a game-related request).
    function triggerDAPPRequest() internal {
        // Add any prior logic here.

        uint256 requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: keyHash,
                subId: subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                // Adding extraArgs is optional.
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({
                    // One of the allowed extraArgs is to tell whether
                    // we will use nativePayments (true) or LINK payments
                    // (false) in our subscription.
                    nativePayment: nativePayments
                }))
            })
        );

        // Storing the request is mandatory. It will not raise any error
        // if not done, but the request will be lost and it will become
        // wasted money and, of course, it is a bug.
        // Custom data is allowed and typically recommended depending on
        // the dapp's logic.
        requests[requestId] = Request({status: RequestStatus.Pending});

        // Emit the custom event, perhaps adding more data. This is
        // optional but a typically useful use case.
        emit RequestStarted(requestId);
    }

    /**
     * Attends any incoming response for the issued requests.
     */
    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {
        // Get any randomWords[0] to randomWords[numWords - 1].
        // They ARE random numbers (you're charged for any number
        // generated this way, as part of the whole execution).

        // Fulfill the request. It is guaranteed that the record
        // will exist, as long as it is properly stored on launch.
        Request storage request = requests[requestId];
        request.status = RequestStatus.Completed;
        // Fulfilling will involve setting more data in the request.

        // Emit the custom event, perhaps adding more data. This is
        // optional but a typically useful use case.
        emit RequestCompleted(requestId);
    }
}
