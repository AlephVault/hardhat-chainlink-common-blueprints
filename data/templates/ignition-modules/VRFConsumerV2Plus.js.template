const { buildModule } = require("@nomicfoundation/hardhat-ignition/modules");

module.exports = buildModule("#SCRIPT_NAME#", (m) => {
  // You can pass parameters (e.g. "foo") to this module and attend
  // or capture them by using line like this one:
  //
  // (parameter keys must be valid alphanumeric strings, and parameter
  // values, both expected and default, must be json-serializable ones,
  // which can be numbers, boolean values, strings or null)
  //
  // const foo = m.getParameter("foo", "someValue");
  //
  // These 3 are needed for VRF consumer V2Plus contracts:
  const vrfCoordinator = "#VRF_COORDINATOR#";
  // Since this deployment is intended to be run in the LOCAL network,
  // the keyHash doesn't matter. The coordinator mock does not make
  // use of this value since the gas price is only meaningful in live
  // or test networks to track priority of transactions, but it is not
  // used in local networks, so this value can be arbitrary. The mock
  // will not enforce it. But, yes, it must be a 0x-prefixed string
  // with 64 hex. characters.
  const keyHash = "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
  // It is assumed that this subscription id is known beforehand and
  // specified in the custom-mock method createSubscription(uint256),
  // which is not part of Chainlink's mock but the mock generated by
  // this module. This is intended for subscription ids are stable in
  // the local test environment. So somewhere, in another module, you
  // must have a .createSubscription(#SUBSCRIPTION_ID#) call to the
  // (local) coordinator mock. This is only possible because this
  // module must only be used in LOCAL environments (take a look at
  // the deploy-everything package to understand how). Non-local
  // environments should use the non-local variant blueprint, which
  // expects the subscription id to be created by regular Chainlink
  // methods and well-known web portals.
  const subscriptionId = #SUBSCRIPTION_ID#;

  // This is a simple module which only deploys a contract. The result
  // of m.contract is a special value (not an actual contract nor its
  // address) that makes part of the ignition declarative paradigm: a
  // "future". Read more about ignition and futures in the official
  // documentation @ Hardhat's website.

  // The [] receives as many argument as your contract needs. Those
  // will be passed directly to the constructor.

  const contract = m.contract(
    "#CONTRACT_NAME#", [subscriptionId, vrfCoordinator, keyHash]
  );

  // In this case, the result is a single object having a contract: key
  // which contains the future. When Ignition deployment is invoked and
  // retrieved via code, the result will be a single object having a
  // contract: key which contains a Contract instance (from `ethers` or
  // `viem` or whatever biding you're using for Ignition).

  // Feel free to edit this file as needed, but it's a good idea to keep
  // the object with the contract: key (you can freely add more keys) or
  // other tools based on this one might not work for your script.

  return { contract };
});
